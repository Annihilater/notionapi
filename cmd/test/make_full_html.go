package main

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

/*
Wrap HTML fragment generated by tohtml.ToHTML() if more HTML
to make it fully stand-alone page
*/

var (
	htmlWrap = `
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<style>
	{{ css }}
		</style>
	</head>

<body>
{{ htmlBody }}
</body>

</html>
`
)

var (
	cssFromFile  string
	fullHTMLWrap string
)

func loadFile(path string) string {
	// ignoring an error, the caller checks returned value for non-empty
	d, _ := ioutil.ReadFile(path)
	return string(d)
}

func loadCSS() string {
	if len(cssFromFile) > 0 {
		return cssFromFile
	}
	path1 := filepath.Join("cmd", "test", "main.css")
	cssFromFile = loadFile(path1)
	if len(cssFromFile) > 0 {
		return cssFromFile
	}
	path2 := filepath.Join("test", "main.css")
	cssFromFile = loadFile(path1)
	if len(cssFromFile) > 0 {
		return cssFromFile
	}
	log("couldn't load css from the following files:\n%s\n%s\n", path1, path2)
	os.Exit(1)
	return ""
}

func getFullHTMLWrap() string {
	if len(fullHTMLWrap) == 0 {
		css := loadCSS()
		fullHTMLWrap = strings.Replace(htmlWrap, "{{ css }}", css, -1)
		if fullHTMLWrap == htmlWrap {
			panic("failed to replace {{ css }} in htmlWrap")
		}
	}
	return fullHTMLWrap
}

// wrap HTML body in more HTML to create a full, stand-alone HTML page
func makeFullHTML(htmlBody []byte) []byte {
	wrap := getFullHTMLWrap()
	html := strings.Replace(wrap, "{{ htmlBody }}", string(htmlBody), -1)
	if len(htmlBody) > 0 && wrap == html {
		panic("failed to replace {{ htmlBody }} in fullHTMLWrap")
	}
	return []byte(html)
}
